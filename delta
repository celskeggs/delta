#!/bin/python3
import os
import sys
import crypto
import tree
import common
import remote
import inspect

commands = {}


def count_args(command):
    optional = 0
    required = 0
    for p in inspect.signature(command).parameters.values():
        if p.kind in (inspect.Parameter.POSITIONAL_ONLY, inspect.Parameter.POSITIONAL_OR_KEYWORD):
            optional += 1
            if p.default is None:
                required += 1
    return required, optional + required


def add_command(command):
    name = command.__name__
    min_args, max_args = count_args(command)

    def checked(args):
        args = args[1:]
        if len(args) < min_args:
            raise common.DeltaException("Too few arguments to %s." % name)
        elif max_args is not None and len(args) > max_args:
            raise common.DeltaException("Too many arguments to %s." % name)
        else:
            return command(*args)

    commands[name] = checked


def no_such_command(args):
    raise common.DeltaException("Unknown command: %s" % args[0])


# Commands

@add_command
def init(key=None):
    if tree.find_ctx(fail=False) is not None:
        raise common.DeltaException("delta root already created.")
    if key is None:
        print("Key expected. Key options:")
        for i, key in enumerate(crypto.list_keys()):
            print("(%d) =>" % i, key["fingerprint"], key["trust"], key["length"], *key["uids"])
        print("Try again with the number.")
    else:
        keys = crypto.list_keys()
        try:
            key = keys[int(args[0])]["fingerprint"]
        except ValueError:
            raise common.DeltaException("Invalid number.")
        except IndexError:
            raise common.DeltaException("Key number not available.")
        tree.init_folder(os.getcwd(), key)
        print("Repo inited with key", key)


@add_command
def stash():
    root, ddir, key = tree.find_ctx()
    print("Delta root:", root)
    link_count, unsaved = tree.tree_status(root)
    if unsaved:
        for f in unsaved:
            tree.stash_file(root, f)
        print("Done stashing!")
    else:
        print("Nothing to stash.")


@add_command
def encrypt():
    root, ddir, key = tree.find_ctx()
    print("Delta root:", root)
    cache_decrypt, cache_encrypt = tree.cache_status(root)
    found_any = False
    for object in cache_decrypt:
        if object not in cache_encrypt:
            found_any = True
            tree.encrypt_file(root, key, object)
    if found_any:
        print("Done encrypting!")
    else:
        print("Nothing to encrypt.")


@add_command
def decrypt():
    root, ddir, key = tree.find_ctx()
    print("Delta root:", root)
    cache_decrypt, cache_encrypt = tree.cache_status(root)
    found_any = False
    for object in cache_encrypt:
        if object not in cache_decrypt:
            found_any = True
            tree.decrypt_file(root, key, object)
    if found_any:
        print("Done decrypting!")
    else:
        print("Nothing to decrypt.")


@add_command
def status():
    root, ddir, key = tree.find_ctx()
    print("Delta root:", root)
    print("Encryption key:", key)
    link_count, unsaved = tree.tree_status(root)
    cache_decrypt, cache_encrypt = tree.cache_status(root)
    cache_needs_encrypt = len([x for x in cache_decrypt if x not in cache_encrypt])
    cache_needs_decrypt = len([x for x in cache_encrypt if x not in cache_decrypt])
    print("Object count:   ", len(cache_decrypt), ("\t+%d" % cache_needs_decrypt) if cache_needs_decrypt else "")
    print("Encrypted count:", len(cache_encrypt), ("\t+%d" % cache_needs_encrypt) if cache_needs_encrypt else "")
    print("Stashed count:  ", link_count, ("\t+%d" % len(unsaved)) if unsaved else "")
    for f in unsaved:
        rel = os.path.relpath(f)
        print("\t%s" % (rel if rel[0:3] == "../" else "./" + rel,))


@add_command
def sync():
    root, ddir, key = tree.find_ctx()
    print("Delta root:", root)
    loaded_tree = tree.get_tree(root)
    if loaded_tree != None:
        changes = list(tree.list_changes(root, loaded_tree))
        print("Found %d changes." % len(changes))
        if changes:
            for i, change in enumerate(changes, 1):
                print("%3d." % i, *change)
                if input("Apply change? ")[0:1].lower() == "y":
                    tree.apply_change(root, change)
                    print("Applied.")
            print("Finished changes.")
    if tree.get_tree(root) != tree.dump_tree(root) and input("Store tree? ")[0:1].lower() == "y":
        tree.set_tree(root, tree.dump_tree(root))
        print("Stored.")


@add_command
def up():
    root, ddir, key = tree.find_ctx()
    objects_upstream = remote.list_upstream()
    objects_local = tree.cache_status(root)[1]
    objects_to_upload = [object for object in objects_local if object not in objects_upstream]
    print("Going to upload %d objects." % len(objects_to_upload))
    for object in objects_to_upload:
        with tree.export_object(root, object) as f:
            print("Uploading:", object)
            remote.upload_object(object, f)
    print("Uploading tree...")
    data = tree.get_tree_crypt(root, key)
    remote.upload_object(tree.TREEFILE, data, overwrite=True)
    print("Uploaded!")


@add_command
def down():
    root, ddir, key = tree.find_ctx()
    objects_upstream = remote.list_upstream()
    objects_local = tree.cache_status(root)[1]
    objects_to_download = [object for object in objects_upstream if object not in objects_local]
    print("Going to download %d objects." % len(objects_to_download))
    for object in objects_to_download:
        with tree.import_object(root, object) as f:
            print("Downloading:", object)
            remote.download_object(object, f)
    print("Downloading tree...")
    if remote.exists_object(tree.TREEFILE):
        tree.set_tree_crypt(root, key, remote.download_object(tree.TREEFILE, None))
        print("Downloaded!")
    else:
        print("No tree to download.")


@add_command
def help():
    print("Commands:", *sorted(commands.keys()))


# Main

if __name__ == "__main__":
    try:
        commands.get(sys.argv[1] if sys.argv[1:] else "status", no_such_command)(sys.argv[1:])
    except common.DeltaException as e:
        print("Failed:", str(e))
